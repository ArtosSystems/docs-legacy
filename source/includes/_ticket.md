# Aventus Tickets

On the Aventus Protocol - a ticket consists of specific pieces of data; some unique data used to identify and reference the ticket, and some metadata used by applications like the ticket wallet.

Before tickets are written to the blockchain (either via our scaling service or directly) they exist in a preliminary stage as a hyperlink created by METaL to be loaded (or claimed) by a ticket wallet. Firstly, we'll define the content of a ticket link generated by METaL, then the definition of a merkle leaf ticket once opened by a wallet.

<aside class="notice">
For the current purposes of what we're doing right now, we have two kinds of ticket. A blockchain ticket, and a merkle leaf (one that is using our scaling solution, Modest) ticket. All tickets that we will produce start off as merkle leaf tickets.
</aside>

## Ticket Links

The unique data inside of a ticket link consists of a vendor reference and an event ID. Metadata consists of everything else, i.e. other data that is relevant to the event itself.

It is important to note that the Protocol has no opinion on what is inside of a ticket, it is up to clients to enforce and parse what a ticket really contains. With that in mind, it is possible to understand what extra pieces of metadata you may want to include inside of a ticket. It is not limited to what is below, but remember whatever client you build needs to be able to understand the JSON object structure below.

Specifically, it is the combination of the vendorReference and eventId is what makes a ticket unique.

The combination of the above, and ticketMeta (metadata, in our case, any other information that is stored in a ticket, such as venue, seat, gate, email, etc)

Parameter | Type | Description
--------- | ------- | -----------
eventId* | string  | a unique identifier used to reference an event on the Aventus Protocol
vendorReference*  |  string | a unique identifier used to tie an event to a vendor (Primary)
email*  |  string | **metadata**: customer email address
payload*  | string  |  **metadata**: provided by METaL
secret*  | string  |  **metadata**: provided by METaL
link*  | string  |  **metadata**: the link generated by METaL for use of a ticket in the Wallet.

<aside class="notice">
* indicates a required field
</aside>

```JSON
{
    "vendorReference": "ref 1543005210191",
    "eventId": "3",
    "payload": "payload",
    "email": "customer2@aventus.io",
    "secret": "7b52931c-e1a9-4b7d-bf06-c2f0d9562d3a",
    "link": "artos.ticketwallet://+?payload=W3siZXZlbnRJZCI6IjUiLCJ0aWNrZXRSZWZlcmVuY2UiOiJyZWYgMTU0MzAwNTIxMDE5MSIsInBheWxvYWQiOiJ7c29tZVN0dWZmV2hhdGV2ZXJGb3JtYXRQYXlsb2FkfSIsImRhdGFTaWduYXR1cmUiOiIweDE2MGRlMjIzNDc1NmY0MWNlYzU1MDZmNGZjZWUxZTg3MTUzNmYwZmI3YWVlN2EyMDE4ZmJjODdjOWRhNzNiZmM3Zjg5ZDQ0MDA2ZDAzN2Y5YmEzZTc0NmIxNDIzMTJiNWU5Nzc1MTRkZDAwNjlhNDUwODdlNDRmZGY1Y2VhNmM2MDEiLCJzZWNyZXQiOiJNeSBhbWF6aW5nIHNlY3JldCIsInNlY3JldFNpZ25hdHVyZSI6IjB4YzY5MWUyMTdhOTZlNGVhZTQ5MDhmYzM4MjlmNGVmNDk0MDBlNDc1MGIxNzZmMWJiMDhlYWE3MjM2NTkzOTJjNDY3NTZhMGMzODQ0Yzk0NTEwZTkxNDdjYjllZDhiOWY0Yjc2MGJlZGM2YjZiNTJhOWM0MTMyMDA5ODAyNTk1YjMwMCJ9XQ==",
    "status": "sent"
  },
```

In terms of what a ticket looks like as a JSON object, see right (or above, if on mobile).

## Ticket Definition

> What a ticket _really_ consists of

```
secret -> very_very_secret,
payload -> {\"eventName\": \"Stubborn Event\", \"eventTime\": 1543255200, \"eventVenue\": \"Hell\"},
ticketRef -> stubborn-4064,
eventId -> 1,
primarySignedSecret -> 0x7a4a1ade9fa66db3227574384fcd20dd244bed5ef36ed7fbab08e92f0ffa3e2949c1df37a5cf0f360bf500c72509f313238a2935158eb940753285505dfff25c00,
doublySignedSecret -> 0x655b1710acd74d630352bb25ad031d9803fdba094b3a921399300abbf85e95d83d3805b7b6057148f9134ce3ce52e3114614b15ab585b285fa45c7e55d99655000,
primarySignedTicketData -> 0xf126ffc2a84ed5bfec1a40a02be5af6fbddaee19796ae36feee1471c38aa6a80625cd3933a9739529c595e0544886cfbf0555f9d2a35a434f31f5dc963a8a37500,
customerSignedData -> 0x50256df6e9173f1396d018125936efa3b909df0831e7f55cbd59074d5f9616ad316054c658838dcc0286cb7dbb4d9057a7dddb69480d3f1cef19fe993e77327300
```

The first example is what the Ticket Wallet sends to the nessessary lambda.

Anything that is `primarySigned` is coming from the link generator on completion of a ticket (through METaL, mostly). What has been signed by the customer (including `doublySignedSecret`) comes from the wallet.

> Customer Signed Data contains:

```json
customerSignedData = sign(“$payload|$eventId|$ticketRef|${link.secret}|$secretSignature|$doublySignedSecret|$ticketDataSignature”, customerPrivateKey)
```

> doublySignedSecret contains:


```
doublySignedSecret = sign(primarySecretSignature, customerPrivateKey)
```


<aside class="notice">
For the current purposes of what we're doing right now, we have two kinds of ticket. A ticket, and a merkle leaf (one that is using our scaling solution, Modest) ticket. Currently, all tickets that we will produce are merkle leaf tickets - thus, all our examples are merkle leaf tickets.
</aside>

> An empty ticket specification


```
- Ticket Data
- PuK1
- Signed[Primary](TicketData, PuK1)
- Signed[PrK2](Signed[Primary](DoorData))
```

#### Definitions

- **Primary** a primary seller or event owner (event owners can sell their own tickets)
- **LeafContent** the entirety of the leaf content: TicketData, PuK1, Signed[Primary](TicketData, PuK1) and if non-integrated AC the Signed[PuK2] (Signed[Primary] (DoorData))
- **ticketData** = eventID, vendorID, ticketMeta (potentially a JSON object used by wallet, contains things like; venue, seat #, gate #, etc.)
- **PuK1** public key of ticket buyer, generated by wallet, used for proof of ticket ownership to blockchain (and proof at door if AC is integrated)
- **PuK2** public key of ticket buyer, generated by wallet, used for proof of ticket at the door in the the non-integrated AC scenarios
- **NewPuK1** public key of new ticket buyer when a ticket is resold on a secondary market, used for proof of ticket ownership to blockchain (and proof at door if AC is integrated)
- **Door Data (previously Secret or TicketKey)** primary issued secret that is used to EC recover the ticket holders PuK2 in the non-integrated AC scenarios
- **Merkle Proof** Used to check the validity of LeafContent by showing the complete path to a leaf within a Merkle Root
- **doublySignedSecret** = sign(primarySecretSignature, customerPrivateKey)
